---
layout: book
title: 代码的坏味道
book: refactor
---

## 1.  Duplicated Code（重复代码）

在一个以上的地方看到相同的程序结构。
* 复用性差
* 代码膨胀混乱，难以维护

场景：
* case1：同一个类的两个函数含有相同的表达式。
* case2：两个互为兄弟的子类中含有相同的表达式。
* case3：两个毫不相关的类中含有相同的表达式。

解决：提取公共函数。


## 2.  Long Method（过长函数）

函数的实现太长，有的甚至一屏幕都看不完。
* 程序愈长就愈难理解
* 函数过长阅读起来也不方便
* 小函数的价值：解释能力、共享能力、选择能力

原则：每当感觉需要以注释来说明代码用途和实现手法之间的语义距离时，可以将这段代码替换成一个独立的函数。条件表达式和循环常常也是提炼的信号。


## 3.  Large Class（过大的类）

想利用单一类做太多事情。
* 类内往往会出现太多实例变量。
* 一个类如果拥有太多的代码，也是代码重复、混乱、死亡的绝佳滋生地点。

解决：将相关的几个变量提取到一个新的类。做太多事情的类，可以考虑把责任委托给其他类。

## 4.  Long Parameter List（过长参数列）

把函数所需的所有东西都以参数传递进去。
* 太长的参数列难以理解。
* 太多参数会造成前后不一致，不易使用。
* 当需要更多数据时，不得不修改它。

解决：将参数封装成结构或者类，并将对象传递给函数。


## 5.  Divergent Change（发散式变化）

一个类受多种需求变化的影响（万能类）。

* 数据库新加一个字段，同时修改三个函数：Load、Insert、Update
* 新加一个角色二进制，同时修改四处
* …

原则：针对某一外界变化的所有相应修改，都只应该发生在单一类中。

解决：找出某特定原因而造成的所有变化，然后将它们提炼到另一个类中（将总是一起变化的东西放在一块儿）。

## 6.  Shotgun Surgery（霰弹式修改）
一种变化引发多个类的修改（改某个需求的时候，要改很多类）。
* 需要修改的代码散布四处，你不但难以找到它们，也很容易忘记某个重要的修改。

解决：将各个修改点集中起来，抽象成一个新类。


## 7.  Feature Envy（依恋情结）
函数对某个类的兴趣高过对自己所处类的兴趣（使用了大量其他类的成员）。
* 对其他类产生依恋情节，造成紧耦合。

原则：
* 判断哪个类拥有最多被此函数使用的数据，然后将这个函数和那些数据摆在一起。
* 将总是一起变化的东西放在一块。


## 8.  Data Clumps（数据泥团）
有些数据项，喜欢成群结队地待在一块：一起出现在很多类的成员变量中，一起出现在许多方法的参数中….。
* 导致字段和参数的个数太多，函数调用困难。

解决：把这些数据项放在一个新的类里面。


## 9. Primitive Obsession（基本类型偏执）
代码中有很多基本数据类型的数据。
* 基本数据类型字段越来越多，代码可读性差。
* 不易于管理这些数据。

原则：如果看到一些基本类型数据（反复出现的一组参数，有关联的多个数组），尝试定义一种新的数据类型，符合它当前所代表的对象类型。

## 10.  Switch Statements（switch惊悚现身）
面向对象程序的一个最明显特征就是：少用switch（或case）语句。
* switch语句的问题在于重复。

原则：看到switch你就应该考虑使用多态来替换它。


## 11.  Parallel Inheritance Hierarchies （平行继承体系）
并行的继承层次是Shotgun Surgery的特殊情况。
* 当你改变一个层次中的某一个类时，你必须同时改变另外一个层次的并行子类。 

解决：让一个继承体系的实例引用另一个继承体系的实例。


## 12.  Lazy Class（冗赘类）
一个干活不多的类。
* 类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。 

解决：
* 如果某些子类没有做足够的工作，考虑折叠继承体系；
* 对于几乎没用的组件，考虑将类内联化。


## 13.  Speculative Generality （夸夸其谈未来性）
实现了从未用到的功能和通用性。
* 对未来不可预知的变化考虑的过多，造成系统更难理解和维护。
* 如果应对变化的代码都会被用到，那是值得的那么做；如果用不到，就不值得。

场景：
* 某个抽象类其实并没有太大作用。
* 函数的某些参数未被用上。
* 函数名带有多余的抽象意味。

原则：代码应该满足当前的需求，并留有可扩展的余地。对于未来的变化，既不要考虑的太多，也不能一点都不考虑。


## 14.  Temporary Field （令人迷惑的暂时字段）
一个对象的属性可能只在某些情况下才有意义。
* 这样的代码将难以理解。

场景：一个特定的算法需要某些只有该算法才有用的变量。

解决：将这样的孤儿属性集中到一个新类中管理，然后把和它相关的行为移到该类。


## 15.  Message Chain （过度耦合的消息链）
当一个类使用了另一个类，而那个类又使用了另外一个类，并以此类推。
* 客户代码将与查找过程中导航结构紧密耦合。

解决：通过拆函数或者移动函数来缩短链。


## 16.  Middle Man（中间人）
过度使用委托。
* 某个类的接口有一半的函数都委托给其他类，这样就过度运用了。

解决：
* 如果这样“不干实事”的函数只有少数几个，可以将它们放进调用端。
* 如果中间人还有其它行为，可以把它变成实责对象的子类，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作（用继承替代委托）。


## 17.  Inappropriate Intimacy（狎昵关系）
某些类相互之间太亲密。
* 它们花费了太多的时间去探究彼此的私有部分。
*

解决：
* 拆散（“移动方法”和“移动字段”），或合并（提取共同点），或通过隐藏“委托关系”让另一个类来为它们传递消息。
* 继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观意愿，通过以委托取代继承让它离开继承体系。


## 18.  Alternative Classes with Different Interfaces（异曲同工的类）
两个函数做同一件事，却有不同的签名。
* 代码重复。

解决：一致把它们往类层次上移，直至两者的协议一致。

## 19.  Incomplete Library Class （不完美的库类）
要建立一个好的类库非常困难。我们大量的程序工作都基于类库实现。
* 如此广泛而又相异的目标对库构建者提出了苛刻的要求。库构建者也不是万能的。
* 有时候我们会发现库类无法实现我们需要的功能。而直接对库类的修改有非常困难。

解决：
* 如果你只想修改库类的一两个函数，可以使用**[Introduce Foreign Method](introduce-foreign-method.html)**来进行修改。
* 如果想要添加一大堆额外行为，就得运用**[Introduce Local Extension](introduce-local-extension.html)**（建立一个新类，使它包含这些额外函数。让这个扩展类成为源类的子类或包装类）来进行修改。


## 20.  Data Class（纯稚的数据类）
Data Class是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。
* 这样的类只是一种不会说话的数据容器，它们几乎一定被其它类过分细琐地操控着。

解决：
>1. 对于public成员变量，运用**[Encapsulate Field](encapsulate-field.html)**进行封装。
>2. 对于容器类字段，运用**[Encapsulate Collection](encapsulate-collection.html)**进行封装。
>3. 对于那些不该被其它类修改的字段，运用**[Remove Setting Method](remove-setting-method.html)**去掉该字段的所有设值函数。
>4. 将相关操作封装到Data Class。


## 21.  Refused Bequest（被拒绝的遗赠）
子类应该继承超类的函数和数据。但是如果它们不想或者不需要继承，又该怎么办呢？

解决：即使不愿意继承接口，也不要胡乱修改继承体系，应该运用**[Replace Inheritance Delegation](replace-inheritance-delegation.html)**（以委托取代继承）。

## 22. Comments（过多的注释）
过多注释的代码段，往往都是因为那段代码比较糟糕。
* 代码太难理解，不得不用注释解释。

原则：当你感觉需要写注释时，请尝试重构，试着让所有注释都变得多余。



